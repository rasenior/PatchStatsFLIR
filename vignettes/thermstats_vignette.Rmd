---
title: "Using ThermStats to calculate statistics for thermal images"
output:
  rmarkdown::html_vignette:
    toc: true
  rmarkdown::pdf_document:
    toc: true
author: Rebecca A. Senior
date: "`r format(Sys.time(), '%d %B, %Y')`"
vignette: >
  %\VignetteIndexEntry{Using ThermStats to calculate statistics for thermal images}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
link-citations: yes
csl: E:/GoogleDrive/Referencing/Citation styles/elsevier-harvard.csl
biblio-style: apalike
bibliography: [refs.bib, funky-refs.bib]
fontsize: 12pt
geometry: margin=2.5cm
mainfont: Calibri
lang: en-GB
papersize: a4
documentclass: article
header-includes:
- \usepackage{url}
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhf{}
- \fancyfoot[CO,CE]{\thepage}
- \usepackage{setspace}
- \doublespacing
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.align = "centre", fig.width = 16.6/2.54)
```

# Summary

`ThermStats` is designed for biologists using thermography to quantify thermal heteorgeneity. It uses the `Thermimage` package [@tattersall_thermimage:_2017] to batch process data from FLIR thermal cameras, and takes inspiration from FRAGSTATS [@fragstats_2012], `SDMTools` [@sdmtools_2014], @faye_toolbox_2016 and @shi_framework_2016 to facilitate the calculation of various metrics of thermal heterogeneity for any gridded temperature data.

The package is available to download from GitHub using `devtools`:

```{r install, eval = -1}
devtools::install_github("rasenior/ThermStats")
library(ThermStats)
```

# Extracting raw data

```{r batch-extract, echo= TRUE, results = "hide"}
# Batch extract four FLIR thermal images included in ThermStats
flir_raw <-
  # NOTE this step may not work if there are spaces in the path to 
  # where the package is installed
   batch_extract(system.file("extdata", package = "ThermStats"),
                 write_results = FALSE)
```

# Converting raw data to temperature

```{r batch-convert, echo= TRUE, results = "hide"}
# Load raw data
raw_dat <- flir_raw$raw_dat
camera_params <- flir_raw$camera_params
metadata <- flir_metadata

# Create vector denoting the position of each photo within 
# the metadata dataframe
photo_index <- match(names(raw_dat), metadata$photo_no)

# Define environmental parameters -------------------------

# Emissivity is mean of range given in Scheffers et al. 2017
E <- mean(c(0.982,0.99))

# Object distance is calculated as the hypotenuse of a 
# right triangle where the vertical side is 1.3 m (breast 
# height) and the angle down is 45 degrees
OD <- (sqrt(2))*1.3

# Apparent reflected temperature, atmospheric temperature 
# and infrared window temperature set as the atmospheric 
# temperature measured in the field
RTemp <- metadata$atm_temp[photo_index]
ATemp <- metadata$atm_temp[photo_index]
IRWTemp <- metadata$atm_temp[photo_index]

# Infrared Window transmission is kept at default
IRT <- 1

# Relative humidity is set as the relative humidity 
# measured in the field.
RH <- metadata$rel_humidity[photo_index]

# Define camera parameters --------------------------------

# These parameters are calibration constants, and therefore 
# constant for each camera
PR1 <- camera_params[,"PlanckR1"]
PB <- camera_params[,"PlanckB"]
PF <- camera_params[,"PlanckF"]
PO <- camera_params[,"PlanckO"]
PR2 <- camera_params[,"PlanckR2"]

# Batch convert -------------------------------------------
flir_converted <-
    batch_convert(raw_dat,
                  E, OD, RTemp, ATemp, IRWTemp, IRT, RH,
                  PR1, PB, PF, PO, PR2,
                  write_results = FALSE)
```

# Calculating thermal statistics

```{r get-stats, echo= TRUE, results = "hide"}
flir_stats <-
    get_stats(
        # The temperature matrix 
        val_mat = flir_converted$`8565`,
        # The ID of the matrix
        matrix_id = "8565",
        # Whether or not to identify hot and cold spots
        get_patches = TRUE,
        # The size of the neighourhood 
        # (for calculating the local G statistic)
        k = 8,
        # The neghbour weighting style 
        # (for calculating the local G statistic)
        style = "W",
        # The matrix projection
        # (only relevant for geographic data)
        mat_proj = NULL,
        # The matrix extent
        # (only relevant for geographic data)
        mat_extent = NULL,
        # The data to return
        return_vals = c("df", "patches", "pstats"),
        # The names of the statistics functions
        pixel_fns = NULL,
        # The summary statistics
        median, perc_5, perc_95, SHDI
    )
```

```{r stats-by-group, results = "hide"}
flir_stats_group <-
    stats_by_group(
        # A dataframe denoting the grouping
        metadata = metadata,
        # List of temperature matrices
        mat_list = flir_converted,
        # Variable denoting the matrix IDs
        matrix_id = "photo_no",
        # Variable denoting the grouping
        grouping_var = "rep_id",
        # Desired precision of data
        round_val = 0.5,
        # The size of the neighourhood 
        # (for calculating the local G statistic)
        k = 8,
        # The neghbour weighting style 
        # (for calculating the local G statistic)
        style = "W",
        # Some summary statistics
        median, perc_5, perc_95, SHDI
        )
```



```{r tab-B-1, tidy=FALSE}
knitr::kable(
  head(flir_stats_group[, c(1:5,8,13:17)], 10), booktabs = TRUE,
  caption = "A snippet of hot spot patch statistics returned by 'stats_by_group', which implements 'get_stats' within groups."
)
```

A snippet of hot spot patch statistics returned by stats_by_group, which implements get_stats within groups.

# Plotting

```{r plot-patches, echo= TRUE, results = "hide"}
plot_patches(
    # The raw temperature data
    df = flir_stats$df,
    # The patch outlines
    patches = flir_stats$patches
        )
```

# References










